# coding=UTF-8
#
# Copyright 2017 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import (print_function, division, absolute_import,
                        unicode_literals)
import difflib
import os.path
import shutil
import sys
import tempfile
import unittest
import xml.etree.ElementTree as etree

import defcon
from fontTools.misc.py23 import open
from glyphsLib.builder.constants import GLYPHS_PREFIX
from glyphsLib.interpolation import set_weight_class, set_width_class
from glyphsLib.classes import GSFont, GSFontMaster, GSInstance
from glyphsLib import to_designspace, to_glyphs


# Current limitation of glyphsLib for designspace to designspace round-trip:
# the designspace's axes, sources and instances must be as such:
#  - the axes' min, max must match extreme masters
#  - the axes' default must match the "regular master"
#  - the axes' mapping must have as many pairs as instances, each pair
#    matching the (userLoc, designLoc) of an instance. If there are no
#    instances, same requirement but with 1 pair/master
#
# Basically this is to say that the designspace must have been generated by
# glyphsLib in the first place.
#
# More general designspaces (like: axes that go farther than extreme masters,
# mapping with arbitrary numbers of pairs...) might be supported later, if/when
# Glyphs gets a UI to setup this information.
#
# REVIEW: check that the above makes sense


def makeFamily():
    m1 = makeMaster("Regular", weight=90.0)
    m2 = makeMaster("Black", weight=190.0)
    instances = [
        makeInstance("Regular", weight=("Regular", 400, 90)),
        makeInstance("Semibold", weight=("SemiBold", 600, 128)),
        makeInstance("Bold", weight=("Bold", 700, 151), is_bold=True),
        makeInstance("Black", weight=("Black", 900, 190)),
    ]
    return [m1, m2], instances


def makeMaster(styleName, weight=None, width=None):
    m = GSFontMaster()
    m.name = styleName
    if weight is not None:
        m.weightValue = weight
    if width is not None:
        m.widthValue = width
    return m


def makeInstance(name, weight=None, width=None, is_bold=None, is_italic=None,
                 linked_style=None):
    inst = GSInstance()
    inst.name = name
    if weight is not None:
        # Glyphs 2.5 stores the instance weight in two to three places:
        # 1. as a textual weight (such as “Bold”; no value defaults to
        #    "Regular");
        # 2. (optional) as numeric customParameters.weightClass (such as 700),
        #    which corresponds to OS/2.usWeightClass where 100 means Thin,
        #    400 means Regular, 700 means Bold, and 900 means Black;
        # 3. as numeric weightValue (such as 66.0), which typically is
        #    the stem width but can be anything that works for interpolation
        #    (no value defaults to 100).
        weightName, weightClass, interpolationWeight = weight
        if weightName is not None:
            inst.weight = weightName
        if weightClass is not None:
            inst.customParameters["weightClass"] = weightClass
        if interpolationWeight is not None:
            inst.weightValue = interpolationWeight
    if width is not None:
        # Glyphs 2.5 stores the instance width in two to three places:
        # 1. as a textual width (such as “Condensed”; no value defaults
        #    to "Medium (normal)");
        # 2. (optional) as numeric customParameters.widthClass (such as 5),
        #    which corresponds to OS/2.usWidthClass where 1 means Ultra-
        #    condensed, 5 means Medium (normal), and 9 means Ultra-expanded;
        # 3. as numeric widthValue (such as 79), which typically is
        #    a percentage of whatever the font designer considers “normal”
        #    but can be anything that works for interpolation (no value
        #    defaults to 100).
        widthName, widthClass, interpolationWidth = width
        if widthName is not None:
            inst.width = widthName
        if widthClass is not None:
            inst.customParameters["widthClass"] = widthClass
        if interpolationWidth is not None:
            inst.widthValue = interpolationWidth
    # TODO: Support custom axes; need to triple-check how these are encoded in
    # Glyphs files. Glyphs 3 will likely overhaul the representation of axes.
    if is_bold is not None:
        inst.isBold = is_bold
    if is_italic is not None:
        inst.isItalic = is_italic
    if linked_style is not None:
        inst.linkStyle = linked_style
    return inst


def makeFont(masters, instances, familyName):
    font = GSFont()
    font.familyName = familyName
    font.masters = masters
    font.instances = instances
    return font


class DesignspaceTest(unittest.TestCase):
    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.tmpdir)

    def write_to_tmp_path(self, doc, name):
        path = os.path.join(self.tmpdir, name)
        doc.write(path)
        return path

    def expect_designspace(self, doc, expected_name):
        dirname = os.path.dirname(__file__)
        expected_path = os.path.join(dirname, "..", "data", expected_name)
        return self._expect_designspace(doc, expected_path)

    def _expect_designspace(self, doc, expected_path):
        actual_path = self.write_to_tmp_path(doc, 'generated.designspace')
        with open(actual_path, mode="r", encoding="utf-8") as f:
            actual = f.readlines()
        with open(expected_path, mode="r", encoding="utf-8") as f:
            expected = f.readlines()
        if actual != expected:
            expected_name = os.path.basename(expected_path)
            for line in difflib.unified_diff(
                    expected, actual,
                    fromfile=expected_name, tofile="<generated>"):
                sys.stderr.write(line)
            self.fail("*.designspace file is different from expected")

    def expect_designspace_roundtrip(self, doc):
        actual_path = self.write_to_tmp_path(doc, 'original.designspace')
        font = to_glyphs(doc, minimize_ufo_diffs=True)
        rtdoc = to_designspace(font)
        return self._expect_designspace(rtdoc, actual_path)

    def test_basic(self):
        masters, instances = makeFamily()
        font = makeFont(masters, instances, "DesignspaceTest Basic")
        doc = to_designspace(font, instance_dir='out')
        self.expect_designspace(doc, "DesignspaceTestBasic.designspace")
        self.expect_designspace_roundtrip(doc)

    def test_inactive_from_exports(self):
        # Glyphs.app recognizes exports=0 as a flag for inactive instances.
        # https://github.com/googlei18n/glyphsLib/issues/129
        masters, instances = makeFamily()
        for inst in instances:
            if inst.name != "Semibold":
                inst.exports = False
        font = makeFont(masters, instances, "DesignspaceTest Inactive")
        doc = to_designspace(font, instance_dir='out')
        self.expect_designspace(doc, "DesignspaceTestInactive.designspace")
        self.expect_designspace_roundtrip(doc)

        # Although inactive instances are not exported by default,
        # all instances are exported when intending to roundtrip Glyphs->Glyphs
        doc = to_designspace(font, minimize_glyphs_diffs=True)
        self.assertEqual(4, len(doc.instances))

    def test_familyName(self):
        masters, _ = makeFamily()
        customFamily = makeInstance("Regular", weight=("Bold", 600, 151))
        customFamily.customParameters["familyName"] = "Custom Family"
        instances = [
            makeInstance("Regular", weight=("Regular", 400, 90)),
            customFamily,
        ]
        font = makeFont(masters, instances, "DesignspaceTest FamilyName")
        doc = to_designspace(font, instance_dir='out')
        self.expect_designspace(doc, "DesignspaceTestFamilyName.designspace")
        self.expect_designspace_roundtrip(doc)

    def test_fileName(self):
        masters, _ = makeFamily()
        customFileName = makeInstance("Regular", weight=("Bold", 600, 151))
        customFileName.customParameters["fileName"] = "Custom FileName"
        instances = [
            makeInstance("Regular", weight=("Regular", 400, 90)),
            customFileName,
        ]
        font = makeFont(masters, instances, "DesignspaceTest FamilyName")
        doc = to_designspace(font, instance_dir='out')
        self.expect_designspace(doc, "DesignspaceTestFileName.designspace")
        self.expect_designspace_roundtrip(doc)

    def test_noRegularMaster(self):
        # Currently, fonttools.varLib fails to build variable fonts
        # if the default axis value does not happen to be at the
        # location of one of the interpolation masters.
        # glyhpsLib tries to work around this downstream limitation.
        masters = [
            makeMaster("Thin", weight=26),
            makeMaster("Black", weight=190),
        ]
        instances = [
            makeInstance("Black", weight=("Black", 900, 190)),
            makeInstance("Regular", weight=("Regular", 400, 90)),
            makeInstance("Bold", weight=("Thin", 100, 26)),
        ]
        font = makeFont(masters, instances, "NoRegularMaster")
        designspace = to_designspace(font, instance_dir='out')
        path = self.write_to_tmp_path(designspace, 'noregular.designspace')
        doc = etree.parse(path)
        weightAxis = doc.find('axes/axis[@tag="wght"]')
        self.assertEqual(weightAxis.attrib["minimum"], "100")
        self.assertEqual(weightAxis.attrib["default"], "100")  # not 400
        self.assertEqual(weightAxis.attrib["maximum"], "900")

        self.expect_designspace_roundtrip(designspace)

    def test_postscriptFontName(self):
        master = makeMaster("Master")
        thin, black = makeInstance("Thin"), makeInstance("Black")
        black.customParameters["postscriptFontName"] = "PSNameTest-Superfat"
        font = makeFont([master], [thin, black], "PSNameTest")
        designspace = to_designspace(font, instance_dir='out')
        path = self.write_to_tmp_path(designspace, 'psname.designspace')
        d = etree.parse(path)

        def psname(doc, style):
            inst = doc.find('instances/instance[@stylename="%s"]' % style)
            return inst.attrib.get('postscriptfontname')
        self.assertIsNone(psname(d, "Thin"))
        self.assertEqual(psname(d, "Black"), "PSNameTest-Superfat")

        self.expect_designspace_roundtrip(designspace)

    def test_instanceOrder(self):
        # The generated *.designspace file should place instances
        # in the same order as they appear in the original source.
        # https://github.com/googlei18n/glyphsLib/issues/113
        masters, _ = makeFamily()
        instances = [
            makeInstance("Black", weight=("Black", 900, 190)),
            makeInstance("Regular", weight=("Regular", 400, 90)),
            makeInstance("Bold", weight=("Bold", 700, 151), is_bold=True),
        ]
        font = makeFont(masters, instances, "DesignspaceTest InstanceOrder")
        doc = to_designspace(font, instance_dir='out')
        self.expect_designspace(doc,
                                "DesignspaceTestInstanceOrder.designspace")
        self.expect_designspace_roundtrip(doc)

    def test_twoAxes(self):
        # In NotoSansArabic-MM.glyphs, the regular width only contains
        # parameters for the weight axis. For the width axis, glyphsLib
        # should use 100 as default value (just like Glyphs.app does).
        familyName = "DesignspaceTest TwoAxes"
        masters = [
            makeMaster("Regular", weight=90),
            makeMaster("Black", weight=190),
            makeMaster("Thin", weight=26),
            makeMaster("ExtraCond", weight=90, width=70),
            makeMaster("ExtraCond Black", weight=190, width=70),
            makeMaster("ExtraCond Thin", weight=26, width=70),
        ]
        instances = [
            makeInstance("Thin", weight=("Thin", 100, 26)),
            makeInstance("Regular", weight=("Regular", 400, 90)),
            makeInstance("Semibold", weight=("SemiBold", 600, 128)),
            makeInstance("Black", weight=("Black", 900, 190)),
            makeInstance("ExtraCondensed Thin",
                         weight=("Thin", 100, 26),
                         width=("Extra Condensed", 2, 70)),
            makeInstance("ExtraCondensed",
                         weight=("Regular", 400, 90),
                         width=("Extra Condensed", 2, 70)),
            makeInstance("ExtraCondensed Black",
                         weight=("Black", 900, 190),
                         width=("Extra Condensed", 2, 70)),
        ]
        font = makeFont(masters, instances, familyName)
        doc = to_designspace(font, instance_dir='out')
        self.expect_designspace(doc, "DesignspaceTestTwoAxes.designspace")
        self.expect_designspace_roundtrip(doc)

    def test_variationFontOrigin(self):
        # Glyphs 2.4.1 introduced a custom parameter “Variation Font Origin”
        # to specify which master should be considered the origin.
        # https://glyphsapp.com/blog/glyphs-2-4-1-released
        masters = [
            makeMaster("Thin", weight=26),
            makeMaster("Regular", weight=100),
            makeMaster("Medium", weight=111),
            makeMaster("Black", weight=190),
        ]
        instances = [
            makeInstance("Black", weight=("Black", 900, 190)),
            makeInstance("Medium", weight=("Medium", 444, 111)),
            makeInstance("Regular", weight=("Regular", 400, 100)),
            makeInstance("Thin", weight=("Thin", 100, 26)),
        ]
        font = makeFont(masters, instances, "Family")
        font.customParameters["Variation Font Origin"] = "Medium"
        designspace = to_designspace(font, instance_dir='out')
        path = self.write_to_tmp_path(designspace, 'varfontorig.designspace')
        doc = etree.parse(path)
        medium = doc.find('sources/source[@stylename="Medium"]')
        self.assertEqual(medium.find("lib").attrib["copy"], "1")
        weightAxis = doc.find('axes/axis[@tag="wght"]')
        self.assertEqual(weightAxis.attrib["default"], "444")

        self.expect_designspace_roundtrip(designspace)

    def test_designspace_name(self):
        doc = to_designspace(makeFont([
            makeMaster("Regular", weight=100),
            makeMaster("Bold", weight=190),
        ], [], "Family Name"))
        # no shared base style name, only write the family name
        self.assertEqual(doc.filename, "FamilyName.designspace")

        doc = to_designspace(makeFont([
            makeMaster("Italic", weight=100),
            makeMaster("Bold Italic", weight=190),
        ], [], "Family Name"))
        # 'Italic' is the base style; append to designspace name
        self.assertEqual(doc.filename, "FamilyName-Italic.designspace")

    def test_instance_filtering_by_family_name(self):
        # See https://github.com/googlei18n/fontmake/issues/257
        path = os.path.join(os.path.dirname(__file__), '..', 'data',
                            'MontserratStrippedDown.glyphs')
        font = GSFont(path)

        # By default (no special parameter), all instances are exported
        designspace_all = to_designspace(font)
        assert len(designspace_all.instances) == 18

        # If we specify that we want the same familyName as the masters,
        # we only get instances that have that same family name, and the
        # masters are copied as-is. (basically a subset of the previous doc)
        designspace_no_alternates = to_designspace(
            font, family_name='Montserrat')
        assert len(designspace_no_alternates.instances) == 9

        # If we specify the alternate family name, we only get the instances
        # that have that family name, and the masters are renamed to have the
        # given family name.
        designspace_alternates = to_designspace(
            font, family_name='Montserrat Alternates')
        assert (designspace_alternates.sources[0].familyName ==
                'Montserrat Alternates')
        assert (designspace_alternates.sources[0].font.info.familyName ==
                'Montserrat Alternates')
        assert len(designspace_alternates.instances) == 9


WEIGHT_CLASS_KEY = GLYPHS_PREFIX + "weightClass"
WIDTH_CLASS_KEY = GLYPHS_PREFIX + "widthClass"


class SetWeightWidthClassesTest(unittest.TestCase):

    def test_no_weigth_class(self):
        ufo = defcon.Font()
        # name here says "Bold", however no excplit weightClass
        # is assigned
        set_weight_class(ufo, makeInstance("Bold"))
        # the default OS/2 weight class is set
        self.assertEqual(ufo.info.openTypeOS2WeightClass, 400)
        # non-empty value is stored in the UFO lib even if same as default
        self.assertEqual(ufo.lib[WEIGHT_CLASS_KEY], "Regular")

    def test_weight_class(self):
        ufo = defcon.Font()
        data = makeInstance(
            "Bold",
            weight=("Bold", None, 150)
        )

        set_weight_class(ufo, data)

        self.assertEqual(ufo.info.openTypeOS2WeightClass, 700)
        self.assertEqual(ufo.lib[WEIGHT_CLASS_KEY], "Bold")

    def test_explicit_default_weight(self):
        ufo = defcon.Font()
        data = makeInstance(
            "Regular",
            weight=("Regular", None, 100)
        )

        set_weight_class(ufo, data)
        # the default OS/2 weight class is set
        self.assertEqual(ufo.info.openTypeOS2WeightClass, 400)
        # non-empty value is stored in the UFO lib even if same as default
        self.assertEqual(ufo.lib[WEIGHT_CLASS_KEY], "Regular")

    def test_no_width_class(self):
        ufo = defcon.Font()
        # no explicit widthClass set, instance name doesn't matter
        set_width_class(ufo, makeInstance("Normal"))
        # the default OS/2 width class is set
        self.assertEqual(ufo.info.openTypeOS2WidthClass, 5)
        # non-empty value is stored in the UFO lib even if same as default
        self.assertEqual(ufo.lib[WIDTH_CLASS_KEY], "Medium (normal)")

    def test_width_class(self):
        ufo = defcon.Font()
        data = makeInstance(
            "Condensed",
            width=("Condensed", 3, 80)
        )

        set_width_class(ufo, data)

        self.assertEqual(ufo.info.openTypeOS2WidthClass, 3)
        self.assertEqual(ufo.lib[WIDTH_CLASS_KEY], "Condensed")

    def test_explicit_default_width(self):
        ufo = defcon.Font()
        data = makeInstance(
            "Regular",
            width=("Medium (normal)", 5, 100)
        )

        set_width_class(ufo, data)
        # the default OS/2 width class is set
        self.assertEqual(ufo.info.openTypeOS2WidthClass, 5)
        # non-empty value is stored in the UFO lib even if same as default
        self.assertEqual(ufo.lib[WIDTH_CLASS_KEY], "Medium (normal)")

    def test_weight_and_width_class(self):
        ufo = defcon.Font()
        data = makeInstance(
            "SemiCondensed ExtraBold",
            weight=("ExtraBold", None, 160),
            width=("SemiCondensed", 4, 90)
        )

        set_weight_class(ufo, data)
        set_width_class(ufo, data)

        self.assertEqual(ufo.info.openTypeOS2WeightClass, 800)
        self.assertEqual(ufo.lib[WEIGHT_CLASS_KEY], "ExtraBold")
        self.assertEqual(ufo.info.openTypeOS2WidthClass, 4)
        self.assertEqual(ufo.lib[WIDTH_CLASS_KEY], "SemiCondensed")

    def test_unknown_weight_class(self):
        ufo = defcon.Font()
        # "DemiLight" is not among the predefined weight classes listed in
        # Glyphs.app/Contents/Frameworks/GlyphsCore.framework/Versions/A/
        # Resources/weights.plist
        # NOTE It is not possible from the user interface to set a custom
        # string as instance 'weightClass' since the choice is constrained
        # by a drop-down menu.
        data = makeInstance(
            "DemiLight Italic",
            weight=("DemiLight", 350, 70)
        )

        set_weight_class(ufo, data)

        # we do not set any OS/2 weight class; user needs to provide
        # a 'weightClass' custom parameter in this special case
        self.assertTrue(ufo.info.openTypeOS2WeightClass is None)


# def test_designspace_roundtrip(tmpdir):
#     return
#     doc = DesignSpaceDocument()
#
#     weight = doc.newAxisDescriptor()
#     weight.minimum = 1
#     weight.maximum = 1000
#     weight.default = 400
#     weight.name = "weight"
#     weight.tag = "wght"
#     weight.labelNames['fa-IR'] = "قطر"
#     weight.labelNames['en'] = "Wéíght"
#     weight.map = [(1.0, 10.0), (400.0, 66.0), (1000.0, 990.0)]
#     doc.addAxis(weight)
#
#     # No width axis (to check that a default one is not created)
#
#     # One custom axis
#     craziness = doc.newAxisDescriptor()
#     craziness.minimum = -0.5
#     craziness.maximum = 0.5
#     craziness.default = 0
#     craziness.name = 'craziness'
#     craziness.tag = 'CRZY'
#     craziness.labelNames['en'] = 'Craziness'
#     craziness.map = []
#     doc.addAxis(craziness)
#
#     # Sources
#
#     light_narrow = doc.newSourceDescriptor()
#     light_narrow.font = defcon.Font()
#     light_narrow.filename = 'sources/Cool Font LtNw.ufo'
#     light_narrow.name = 'light_narrow'
#     light_narrow.copyLib = True
#     light_narrow.copyInfo = True
#     light_narrow.copyFeatures = True
#     light_narrow.location = dict(
#         weight=1,  # FIXME: should it be 1 or 10?
#         craziness=0)
#     light_narrow.familyName = "Cool Font"
#     light_narrow.styleName = "Narrow Light"
#     light_narrow.mutedGlyphNames.append("A")
#     light_narrow.mutedGlyphNames.append("Z")
#     doc.addSource(light_narrow)
#
#     bold_narrow = doc.newSourceDescriptor()
#     bold_narrow.font = defcon.Font()
#     bold_narrow.filename = 'sources/Cool Font BdNw.ufo'
#     bold_narrow.name = 'bold_narrow'
#     bold_narrow.location = dict(
#         weight=990,  # FIXME: Should it be 1000 or 990?
#         craziness=0)
#     bold_narrow.familyName = "Cool Font"
#     bold_narrow.styleName = "Narrow Bold"
#     doc.addSource(bold_narrow)
#
#     light_narrow_crazy = doc.newSourceDescriptor()
#     light_narrow_crazy.font = defcon.Font()
#     light_narrow_crazy.filename = 'sources/Cool Font BdNw.ufo'
#     light_narrow_crazy.name = 'light_narrow'
#     light_narrow_crazy.location = dict(
#         weight=1,  # FIXME: should it be 1 or 10?
#         craziness=0.5)
#     light_narrow_crazy.familyName = "Cool Font"
#     light_narrow_crazy.styleName = "Narrow Bold"
#     doc.addSource(light_narrow_crazy)
#
#     # A source with mostly blank attributes to check that it does not crash
#     out_of_place = doc.newSourceDescriptor()
#     out_of_place.font = defcon.Font()
#     doc.addSource(out_of_place)
#
#     # Instances
#
#     # TODO
#
#     font = to_glyphs(doc)
#
#     # TODO: check how stuff is stored for Glyphs
#
#     rtdoc = to_designspace(font)
#
#     # Compare
#     path = os.path.join(str(tmpdir), 'original.designspace')
#     doc.write(path)
#     with open(path) as fp:
#         xml = fp.read()
#     rtpath = os.path.join(str(tmpdir), 'rt.designspace')
#     rtdoc.write(rtpath)
#     with open(rtpath) as fp:
#         rtxml = fp.read()
#
#     assert xml == rtxml


if __name__ == "__main__":
    sys.exit(unittest.main())
